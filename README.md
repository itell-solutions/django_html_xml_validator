# Django HTML and XML Validator

`Django_html_xml_validator` is a Django middleware to validate HTML and XML
responses generated by your application. This includes but is not limited to
Django views using `render()` and Django HTML templates.

Internally the validator uses [lxml](https://lxml.de/), so the validation is
**quite fast**, requires **NO external tools** to be installed and
**does NOT send your data** over the internet to validation services.

This makes it feasible to perform validation while running your test suite.

## Installation

To install, depending on your package manager, run:

```bash
pip install --update django_html_xml_validator
```

or

```bash
poetry add django_html_xml_validator
```

## Usage

To add validation to your project, add it to `settings.MIDDLEWARE`. In most
cases you only want it to validate the HTML generated by your views directly,
so it would be the last entry. Especially if you have other middleware
installed that modifies your HTML like adding the Django Debug toolbar or
minifying it.

For example:

```python
MIDDLEWARE = [
    "..."
    "django_minify_html.middleware.MinifyHtmlMiddleware",
    "debug_toolbar.middleware.DebugToolbarMiddleware",
    "django_html_xml_validator.middleware.HtmlXmlValidatorMiddleware",  # <-- Ensure to validate only your HTML
]
```

With this, responses with a matching content type are validated:

- HTML:
  - application/xhtml+xml
  - text/html
- XML:
  - application/xml
  - text/xml

In case the response is valid, the middleware returns the original response
and HTTP status code verbatim.

In case errors have been found, the response includes an HTML page detailing
the errors with an HTTP status code of 500 (internal server error).

## Configuration

By default, validation is active when the Django debug mode is enabled. In a
reasonably configured project this means during local development and while
running the test suite, but not once deployed to a server.

For more granular control, add the following to `settings.py`:

```python
VALIDATE_HTML = True
VALIDATE_XML = True
```

If you are sure all your HTML pages are actually XHTML (which sadly will not 
be the case as soon as your code contains forms based on standard Django 
forms),  you can enforce HTML to be validated as XHTML:

```python
VALIDATE_HTML_AS_XHTML = True  # WARNING: Will fail with standard form templates
```

## Disabling validation for specific tests

In case validation is not useful for selected tests (for example when
processing deliberately huge documents), it can be disabled with the
[override_settings](https://docs.djangoproject.com/en/4.0/topics/testing/tools/#django.test.override_settings)
annotation. For example:

```python
from django.test import override_settings

@override_settings(VALIDATE_XML=False)
def test_can_build_huge_xml():
    ...
```

## Limitations

- Validation does not apply to stream responses.
- Validation of HTML5 uses a hack to ignore errors about invalid tags on
  sectioning elements like `<nav>` or `<article>`.
- Validation of XML only checks if the document is well-formed but does not
  validate against a schema or DTD. Technically lxml could do all this but
  would require more setup. If you need such a feature, feel free to submit a
  pull request.

## License

Copyright (c) 2022 ITELL.SOLUTIONS GmbH, Graz, Austria.

Distributed under the MIT license. For details refer to the file `LICENSE`. 

The source code is available from 
<https://github.com/itell-solutions/django_html_xml_validator/tree/1-add-validator>.
